<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Docker Kubernetes Tutorial</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.min.css"
    />
    <!--[if lt IE 9]>
      <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.ie.min.css"
      />
    <![endif]-->
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
      integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="/bootstrap-toc.css"
      media="screen"
      charset="utf-8"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css"
    />
    <link
      rel="stylesheet"
      href="/assets/screen.css"
      media="screen"
      charset="utf-8"
    />
    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
      integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
      crossorigin="anonymous"
    ></script>
    <script src="/bootstrap-toc.js" charset="utf-8"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
    <script type="text/javascript">
      (function(i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function() {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );

      ga("create", "UA-19048260-11", "auto");
      ga("send", "pageview");

      hljs.initHighlightingOnLoad();

      // $(function() {
      //   $("#toc").append('<div class="hint">(creates this)</div>');
      // });
    </script>
  </head>
  <body data-spy="scroll" data-target="#toc">
    <!-- <div class="github-fork-ribbon-wrapper right">
      <div class="github-fork-ribbon">
        <a href="https://github.com/Hyacinth-Ali/Docker-Kubernetes-Tutorial">Clone Sample Projects on GitHub</a>
      </div>
    </div> -->
    <div class="container">
      <div class="row">
        <div class="col-sm-3">
          <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
        </div>
        <div class="col-sm-9">
          <h1 id="docker-kubernetes-hands-on-tutorial">Docker Kubernetes Hands-On Tutorial</h1>

<h4 id="based-on-materials-from">Based on Materials from:</h4>

<p><a href="https://docs.docker.com">Docker Documentation</a> <br />
<a href="https://learning.edx.org/course/course-v1:IBM+CC0201EN+3T2020/home">EDX: Introduction to Containers, Kubernetes, and OpenShift</a> <br />
<a href="https://learning.edx.org/course/course-v1:IBM+CC0101EN+2T2021/home">EDX: Introduction to Cloud Computing</a> <br />
<a href="https://www.udemy.com/course/docker-kubernetes-the-practical-guide/">Udemy: Docker &amp; Kubernetes: The Practical Guide</a> <br /></p>

<p>This hands-on tutorial discusses containerization of software applications with Docker and Kubernetes. It provides a step-by-step description (with sample projects) on how to package an application as a container. All the sample projects can be accessed <a href="https://github.com/Hyacinth-Ali/Docker-Kubernetes-Tutorial">here</a>.</p>

<!-- This [Bootstrap](http://getbootstrap.com/) plugin allows you to generate a table of contents for any page, based on the heading elements (`<h1>`, `<h2>`, etc.). It is meant to emulate the sidebar you see on [the Bootstrap v3 documentation site](https://getbootstrap.com/docs/3.3/css/). -->

<h2 id="section-1-the-basics">Section 1: The Basics</h2>

<p><a href="https://docs.docker.com/get-started/overview/">Docker</a> is a famous container engine which allows users to create and manage containers. On the other hand, A container is a standardized independent unit or module of a software (Application code + Dependencies). Docker facilitates development, shipping, and running of software applications across different environments.</p>

<h3 id="docker-architecture">Docker architecture</h3>

<p>Docker employs a client-server architecture. The client side accepts inputs from users and then talks to the Docker Daemon (or dockerd), which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. Another Docker client is Docker Compose, that lets you work with applications consisting of a set of containers.
<!-- <img src="https://user-images.githubusercontent.com/24963911/169084934-b00bff9c-8479-44cd-b3ca-7bdefc0497c3.png" alt="Docker Architecture" style="width:90%;"/> --></p>

<h3 id="docker-installation">Docker Installation</h3>

<p><a href="https://docs.docker.com/get-docker/">Install Docker</a> by following the steps specific for your operating system. Also, you can <a href="https://labs.play-with-docker.com">Play Around with Docker</a> in a browser.</p>

<h3 id="ide-installation">IDE Installation</h3>

<p>Docker supports several IDEs. You are encouraged to use any IDE of your choice. However, for consistency, <a href="https://code.visualstudio.com">Microsoft Visual Studio</a> is used throughout this tutorial.</p>

<h3 id="download-and-run-sample-project">Download and Run Sample Project</h3>

<p>To get started, follow the steps below to download and then run a sample project.</p>

<ul>
  <li>Clone the sample <a href="https://github.com/Hyacinth-Ali/Docker-Kubernetes-Tutorial">projects</a>: Navigate to the folder <em>Section1/basic-node-app</em>, which contains the source code for this quick demo. Open the folder with your IDE, and you will see a very simple <strong>Hello World</strong> NodeJS application, as shown below. <br /></li>
</ul>

<p><img src="https://user-images.githubusercontent.com/24963911/169063666-b9f98e75-26fa-4bc3-98c6-09160213a550.png" alt="Getting Started Demo App" style="width:100%;" /></p>

<ul>
  <li>Run the following commands to start the server of the application:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install
node app.js
</code></pre></div></div>

<p><strong>npm install</strong> downloads and then installs all the depencies in the application, while <strong>node app.js</strong> starts the server on port 3000.</p>

<ul>
  <li>Open your web browser and then navigate to <a href="http://localhost:3000">http://localhost:3000</a> to visualize the response of the server.</li>
</ul>

<h3 id="quick-dive-into-docker-and-container">Quick Dive into Docker and Container</h3>

<p>Here, we containerize the application and then start the container, the complete dockerized application can be found at <em>Section1/basic-node-app-container</em>.</p>

<ol>
  <li>Create a file at the root project and name it <em>Dockerfile</em></li>
  <li>
    <p>Enter the following set of instructions in the file.</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">FROM</span> <span class="nx">node</span><span class="p">:</span><span class="mi">14</span>
<span class="nx">WORKDIR</span> <span class="o">/</span><span class="nx">app</span>
<span class="nx">COPY</span> <span class="kr">package</span><span class="o">*</span><span class="p">.</span><span class="nx">json</span> <span class="o">/</span><span class="nx">app</span>
<span class="nx">RUN</span> <span class="nx">npm</span> <span class="nx">install</span>
<span class="nx">COPY</span> <span class="p">.</span> <span class="p">.</span>
<span class="nx">EXPOSE</span> <span class="mi">3000</span>
<span class="nx">CMD</span> <span class="p">[</span> <span class="dl">"</span><span class="s2">node</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">app.js</span><span class="dl">"</span> <span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>Open a terminal and then navigate to the root project.</li>
  <li>
    <p>Build the image, i.e., create a Docker image based on the <em>Dockerfile</em></p>

    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker build -t demo-image .
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>List existing images to see the new image (demo-image)</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker images
</code></pre></div>    </div>
  </li>
  <li>
    <p>Start a Docker container based on the new image</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -d -p 3000:3000 demo-image
</code></pre></div>    </div>
  </li>
  <li>Navigate to <a href="http://localhost:3000">http://localhost:3000</a> in your browser or use Docker dashboard to open the running container. Also, you can list running containers with the following command.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="section-2-the-main-building-blocks-dockerfile-image-and-container">Section 2: The Main Building Blocks (Dockerfile, Image, and Container)</h2>

<p>Here, we will walk through the steps to containerize a software application with emphasizes on the core building blocks: Dockerfile, Image, and Container.</p>

<h4 id="dockerfile">Dockerfile</h4>

<p>A Dockerfile is a configuration file, which can be used to create a Docker image. It comprises a set of instructions that when executed creates an image. Here, we provide a brief explanation of the instructions we used already to create an image with a <em>Dockerfile</em></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">FROM</span> <span class="nx">node</span><span class="p">:</span><span class="mi">14</span>
</code></pre></div></div>
<p>Here we specify the base image (<em>node</em> image, version:14). The base image provides underlying OS architecture and other packages that are required to run our application.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">WORKDIR</span> <span class="o">/</span><span class="nx">app</span><span class="p">;</span>
</code></pre></div></div>

<p>This instruction specifies the root directory for the image. Hence, all the contents of the image will be stored in the <em>app</em> folder.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">COPY</span> <span class="kr">package</span><span class="o">*</span><span class="p">.</span><span class="nx">json</span> <span class="o">/</span><span class="nx">app</span>
</code></pre></div></div>

<p>This instruction copies all the files with the name <em>package*.json</em> to the root directory of the image. In our example, both package.json and package-lock.json will be copied to the root directory of the image.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">RUN</span> <span class="nx">npm</span> <span class="nx">install</span>
</code></pre></div></div>

<p>This instruction installs all the dependencies that are specified in our .json file. Remember that we had to run <code class="language-plaintext highlighter-rouge">npm install</code> before running our application.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">COPY</span> <span class="p">.</span> <span class="p">.</span>
</code></pre></div></div>

<p>Here, we copy all contents from the folder that contains the <em>Dockerfile</em>, i.e., the root directory of our project and it is represented as a dot. However, the <em>Dockerfile</em> is not copied though. The second dot is the destination folder inside the image. Similarly, the dot implies that the copied contents will be stored in the root directory (or /app) of the image.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">EXPOSE</span> <span class="mi">3000</span>
</code></pre></div></div>

<p>This instruction simply exposes port 3000 so that we can reeach the application from outside the container.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">CMD</span><span class="p">[(</span><span class="dl">"</span><span class="s2">node</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">app.js</span><span class="dl">"</span><span class="p">)];</span>
</code></pre></div></div>

<p>Finally, this instruction runs the containerized application.</p>

<h3 id="image">Image</h3>

<p>An image contains everything required to run an application, including application code, dependencies, libraries, configuirations, and scripts. Also, an image contains other commands for running a container, e.g., <code class="language-plaintext highlighter-rouge">CMD [ "node", "app.js" ]</code> is a command to run the containerized node application. To create an image, we run the command below:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">docker</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">t</span> <span class="nx">demo</span><span class="o">-</span><span class="nx">image</span> <span class="p">.</span>
</code></pre></div></div>

<p>This command downloads all the required images, e.g., the node base image, if they are not yet cached locally in our system. In addition, the command executes all the instructions that are contained in <em>Dockerfile</em> except some commands that are required to run the container, e.g., <code class="language-plaintext highlighter-rouge">CMD [ "node", "app.js" ]</code>. The flag <code class="language-plaintext highlighter-rouge">-t</code> tags our image with a name (demo-image). The demo-image can then be used to refrence the image when we run containers based on the image. And finally, the <code class="language-plaintext highlighter-rouge">.</code> informs Docker to look for the <em>Dockerfile</em> at the root directory of our project.</p>

<h3 id="container">Container</h3>

<p>A container is an independent runnable instance of an image. A container is light weight, fast, portable, and platform indepenent, to name a few. We can run several containers from an image; however, they are independent and each runs in an isolation.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">docker</span> <span class="nx">run</span> <span class="o">-</span><span class="nx">p</span> <span class="mi">3000</span><span class="p">:</span><span class="mi">3000</span> <span class="nx">demo</span><span class="o">-</span><span class="nx">image</span>
</code></pre></div></div>

<p>This <strong>docker run</strong> command instantiates an image, i.e., it creates a new container from the <strong>demo-image</strong>. The <code class="language-plaintext highlighter-rouge">-p</code> maps port 3000 of the host machine to port 3000 in the container. Remember that we specify in the <em>Dockerfile</em> that the application exposes port 3000. Note that both the host port and the container port can have different values.</p>

<h3 id="external-images">External Images</h3>

<p>Instead of creating our own image, we can run a container based on external image. A Docker Hub is an image registory, which stores repositories of images. These images can be pulled to our local machine and then used to start a container. An example is demonstrated below.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">docker</span> <span class="nx">run</span> <span class="o">-</span><span class="nx">it</span> <span class="nx">node</span>
</code></pre></div></div>

<p>Remember that <code class="language-plaintext highlighter-rouge">docker run</code> creates a new container based on an image. In this example, we are using the <em>node</em> image, which we do not have locally. As a result, Docker pulls the image from the Docker Hub and then creates a new container based on the image. The <code class="language-plaintext highlighter-rouge">-it</code> tells Docker to expose an interactive shell from inside the node container to our local machine so that we can interact with the running container.</p>

<h3 id="managing-images-and-containers">Managing Images and Containers</h3>

<p>Here are some commonly used commands to manage images and containers. You can use <code class="language-plaintext highlighter-rouge">--help</code> to explore all the available Docker commands. For example, <code class="language-plaintext highlighter-rouge">docker run --help</code> displays all the docker run command options.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker build . </code>: Build a Dockerfile and then create an Image based on the file
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-t NAME:TAG</code> : Assign a NAME and a TAG to an image</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker run IMAGE_NAME</code> : Create and then start a new container based on image IMAGE_NAME (or use the image id)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">--name NAME </code>: Assign a NAME to the container. The name can be used for stopping and
removing the container etc.</li>
      <li><code class="language-plaintext highlighter-rouge">-d</code> : Run the container in <strong>detached</strong> mode, i.e., output printed by the container is not
visible. Hence, the command prompt or terminal does <strong>NOT</strong> wait for the container to stop</li>
      <li><code class="language-plaintext highlighter-rouge">-it</code> : Run the container in <strong>interactive</strong> mode, i.e., the container or application is then prepared to receive input via the command prompt or terminal. You can stop the container with <strong>CTRL + C</strong> when using the <code class="language-plaintext highlighter-rouge">-it</code> flag</li>
      <li><code class="language-plaintext highlighter-rouge">--rm</code> : Automatically remove the container when it’s stopped.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker ps</code> : List all <strong>running</strong> containers
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-a</code> : List all containers including stopped ones</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker images</code> : List all locally stored images</li>
  <li><code class="language-plaintext highlighter-rouge">docker rm CONTAINER</code> : Remove a container with name CONTAINER (you can also use the container id)</li>
  <li><code class="language-plaintext highlighter-rouge">docker rmi IMAGE</code> : Remove an image by name or id</li>
  <li><code class="language-plaintext highlighter-rouge">docker container prune</code> : Remove all stopped containers</li>
  <li><code class="language-plaintext highlighter-rouge">docker image prune</code> : Remove all dangling images (untagged images)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-a</code> : Remove all locally stored images</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker push IMAGE</code> : Push an image to DockerHub (or another registry) - the image name or tag must include the repository name or url</li>
  <li><code class="language-plaintext highlighter-rouge">docker pull IMAGE</code> : Pull (download) an image from DockerHub (or another registry) - this is done automatically if you just docker run IMAGE and the image wasn’t pulled before</li>
</ul>

<h3 id="introduction-to-environment-variable">Introduction to Environment Variable</h3>

<p>Environment variable allows you to run the same container based on particular IMAGE but in a different modes or configurations. For example, the exposed container port can be a variable as demonstrated below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ENV PORT 3000
EXPOSE $PORT
</code></pre></div></div>

<p>Now, you can run a container based on an image with different ports:</p>

<ul>
  <li>Create an image based on the dockerfile</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build -t demo-image:env .
</code></pre></div></div>

<ul>
  <li>Run a container based on the image and expose port <strong>8000</strong>, instead of the default <strong>3000</strong></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -p 3000:8000 --rm -d --env PORT=8000  demo-image:env
</code></pre></div></div>

<ul>
  <li>Run another container with environment variable file, port=8000. Note that you have to create a file (.env) at the root project directory and then enter <strong>PORT=8000</strong></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -p 3030:8000 --rm -d --env-file .env demo-image:env
</code></pre></div></div>

<h3 id="sharing-images">Sharing Images</h3>
<p>Docker images can be shared with your team members, as well as the public and services that you aim to deploy your container to. In this section, we demonstrate how to share and use images with <a href="https://hub.docker.com/">Docker Hub</a>.</p>

<ol>
  <li>Register with <strong>Docker Hub</strong>, if you do not already have a Docker Hub account.</li>
  <li>Sign in</li>
  <li>Create a repository.</li>
  <li>Push an image to the repository: <code class="language-plaintext highlighter-rouge">docker push &lt;account-name&gt;/&lt;repo-name&gt;:&lt;tage-name&gt;</code></li>
  <li>Pull an image from the repository: <code class="language-plaintext highlighter-rouge">docker pull &lt;account-name&gt;/&lt;repo-name&gt;:&lt;tage-name&gt;</code></li>
</ol>

<h2 id="section-3-container-volumes-and-bind-mounts">Section 3: Container Volumes and Bind Mounts</h2>

<p>Docker container runs in isolation and when a container stops, all the data that are contained in the container are removed by default. <a href="https://docs.docker.com/storage/volumes/">Volume</a> is a Docker built in feature, which allows us to persist our data, e.g., user account details. Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we’d see the same files. Typically, volumes are folders on your host machine hard drive, which are mounted (or made available or mapped) into the containers.
<img src="https://user-images.githubusercontent.com/24963911/169138298-8765e84e-c26c-440d-9dfe-7af412e3b8c6.png" alt="Docker Volumes" style="width:100%;" /></p>

<p>There are two main types of Docker external storage mechanism: <a href="https://docs.docker.com/storage/volumes/">Volumes</a> and <a href="https://docs.docker.com/storage/bind-mounts/">Bind Mounts</a>. Volumes are completely managed by Docker, while Bind Mounts are managed by us via our local machines. Docker volumes can be anonymous or named volumes.</p>

<ol>
  <li>
    <p><strong>Anonymous Volume</strong>: Only Docker knows the name and the location of the volume in your machine. It is specifically created for a single container. It survives after shutdown/restart of a contsiner, unless the container is removed, then the anonymous volume is gone as well. The command below creates an anonymous volume <br />
<code class="language-plaintext highlighter-rouge">docker run -v/app/data [OTHER OPTIONS] IMAGE</code> <br />
<strong>/app/data</strong> represents the data location in the container. Anonymous volume is predominantly used to lock a memory space, e.g., <em>node_module</em>, from being
overriden by bind mount volume. An anonymous volume can be created in a <em>Dockerfile</em>, as well as in the command line.</p>
  </li>
  <li>
    <p><strong>Named Volume</strong>: The volume has a name; still, only docker knows its location in your machine. The command below creates a named volume - <strong>data</strong> <br />
<code class="language-plaintext highlighter-rouge">docker run -v data:/app/data [OTHER OPTIONS] IMAGE</code> <br />
Named volume is not tied to a specific container; hence, it survives shutdown/removal of a container. A named volume can be removed via CLI. It can be used to share data across containers. A named volume cannot be specified in a <em>Dockerfile</em>.</p>
  </li>
  <li>
    <p><strong>Bind Mount</strong>: This external storage binds a known directory in your local machine with another directory in the container. It is often used to bind source code with the container so that the image is not rebuilt after every change in the code. The command below creates a bind mount, which connects a known directory (/path/to/code) in our local machine to a container directory (/app/code)<br />
<code class="language-plaintext highlighter-rouge">docker run -v /path/to/code:/app/code [OTHER OPTIONS] IMAGE</code> <br />
Bind Mount is similar to named volume, except that its location is known to us, i.e., we can physically locate the directory in our local machine. Note that bind mount requires an absolute path on your local machine, not a relative path or use <code class="language-plaintext highlighter-rouge">-v $(pwd):/app</code> for macOS and <code class="language-plaintext highlighter-rouge">-v "%cd%":/app</code> for Windows.</p>
  </li>
  <li>
    <p><strong>Read Only Volume</strong>: This features ensures that container can only read from, but not write to, the path in our local machine. <br />
<code class="language-plaintext highlighter-rouge">docker run -v /path/to/code:/app/code ...:ro</code> <br />
Volumes that need to be written have to be overriden by bind mount volume. Note that this has to be specified in the docker run, not in docker file.</p>
  </li>
</ol>

<h3 id="hands-on-exercise">Hands-On Exercise</h3>
<p>Here, we demonstrate Docker Volumes with a sample node.js application.</p>
<ol>
  <li>Clone the <a href="https://github.com/Hyacinth-Ali/Docker-Kubernetes-Tutorial">sample project</a> and then navigate to <em>Section3/feedback-volume</em>.</li>
  <li>Run the project as a stand-alone server, i.e., without dockerization of the application.</li>
  <li>Create a Docker image from the application</li>
  <li>Run a container based on the image.</li>
  <li>Run a container with an anonymous volume, restarts the container, and then observe what happens.</li>
  <li>Run a container with a named volume, restarts the container, and then observe what happens.</li>
  <li>Run a container with a bind mount, modify the html source code, and then observe what happens.</li>
  <li>Play around with anonymous and named volumes, as well as bind mounts.</li>
</ol>

<h3 id="key-docker-commands">Key Docker Commands</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">docker run -v /path/in/container IMAGE</code> : Create an Anonymous Volume inside a Container</li>
  <li><code class="language-plaintext highlighter-rouge">docker run -v some-name:/path/in/container IMAGE</code> : Create a Named Volume (named some-name ) inside a Container</li>
  <li><code class="language-plaintext highlighter-rouge">docker run -v /path/on/your/host/machine:path/in/container IMAGE</code> : Create a Bind Mount and connect a local path on your host machine to some path in the Container</li>
  <li><code class="language-plaintext highlighter-rouge">docker volume ls</code> : List all currently active / stored Volumes (by all Containers)</li>
  <li><code class="language-plaintext highlighter-rouge">docker volume create VOL_NAME</code> : Create a new (Named) Volume named VOL_NAME . You typically don’t need to do that, since Docker creates them automatically for you if they don’t exist when running a container</li>
  <li><code class="language-plaintext highlighter-rouge">docker volume rm VOL_NAME</code> : Remove a Volume by it’s name (or ID)</li>
  <li><code class="language-plaintext highlighter-rouge">docker volume prune</code> : Remove all unused Volumes (i.e. not connected to a currently running or stopped container)</li>
</ul>

<h2 id="section-4-multi-container-applications">Section 4: Multi Container Applications</h2>

<p>So far, we have been working with single container applications. However, what if we want to add a database to our application stack, e.g., MySQL. The following question often arises - “Where will MySQL run? Install it in the same container or run it separately?” In general, each container should do one thing and do it well. Hence, it is preferred to separate the processes.</p>

<p>Remember that containers, by default, run in isolation and don’t know anything about other processes or containers on the same machine. So, how do we allow one container to talk to another? The answer is networking.</p>

<p>Here, we present three types of container communication:</p>

<ol>
  <li>Containers talking to external application, e.g., an application running in the web. This type of communication doesn’t require any special configuration or setup. It works as though the application is not dockerized</li>
  <li>Container talking to the local machine, e.g., database running in the local machine. Here, you are required to create a network that comprises our dockerized application and the dockerized database process. This, however, requires a simple change in your url that conects to the database, <code class="language-plaintext highlighter-rouge">localhost</code> -&gt; <code class="language-plaintext highlighter-rouge">host.docker.internal</code>. Docker understands the command <code class="language-plaintext highlighter-rouge">host.docker.internal</code>, which it translates to the IP address of your host machine.</li>
  <li>Container talking to another container, e.g., database running in a container. Containers can communicte between each other with IP address or via a network with the name of the container.
    <ul>
      <li>Use the following command to retrieve the IP address of a running container <br />
  <code class="language-plaintext highlighter-rouge">docker inspect NAME|ID</code></li>
    </ul>
  </li>
</ol>

<p>Application container can communicate with other container, e.g., mongodb, with the IP address of the mongodb container. The IP address can be gotten with <code class="language-plaintext highlighter-rouge">docker container inspect mongodb</code> where mongodb is the name of the mongodb container. The inspect command prints several details including the IP address. This IP Address can be plugged in the url that is used to connect to the database.</p>

<p>Containers can also communicate between one another with network. Docker creates network as follows:
<code class="language-plaintext highlighter-rouge">docker network create &lt;network-name&gt;</code> Then use the network name while running the container as <em>–network network-name</em></p>

<h4 id="hands-on-exercise-1">Hands-On Exercise</h4>
<p>Here, we demonstrate cross-container communication with a sample node.js application.</p>
<ol>
  <li>Clone the <a href="https://github.com/Hyacinth-Ali/Docker-Kubernetes-Tutorial">sample project</a> and then navigate to <em>Section4/container-network-starting</em>.</li>
  <li>Run the project as a stand-alone server, i.e., without dockerization of the application. This works if you have mongodb running in your local machine.
    <ul>
      <li>Otherwise, remove the database connection to run the application.</li>
    </ul>
  </li>
  <li>Create a Docker image from the application.</li>
  <li>Run a container based on the image. Running the container crashes because the container is not configured to communicate with the local machine.</li>
  <li>Replace <strong>localhost</strong> with <strong>host.docker.internal</strong> in the database url to allow containers based on the appliocation communicate with the local machine, as well as the MongoDb running in the local machine.</li>
  <li>Run mongo container</li>
  <li>Connect the container to the mongodb with the mongodb IP address</li>
</ol>

<h3 id="container-networking">Container Networking</h3>

<p><a href="https://docs.docker.com/network/">Docker Network</a> allows containers to communicate between each other and IPs are automatically resolved. The command below creates a network <br />
<code class="language-plaintext highlighter-rouge">docker network create my_network</code>
This is also called <a href="https://docs.docker.com/network/bridge/">user defined bridge network</a>.
You can specify the subnet, the IP address range, the gateway, and other options. See the docker network create reference or the output of <code class="language-plaintext highlighter-rouge">docker network create --help</code> for details.</p>

<p>Use the <code class="language-plaintext highlighter-rouge">docker network rm</code> command to remove a user-defined bridge network. If containers are currently connected to the network, disconnect them first. <br />
<code class="language-plaintext highlighter-rouge">docker network rm my_network</code></p>

<p>To disconnect a running container from a user-defined bridge network, use the <code class="language-plaintext highlighter-rouge">docker network disconnect</code> command. The following command disconnects the my-demo container from the my-network network.</p>

<p><code class="language-plaintext highlighter-rouge">docker network disconnect my-network my-demo</code></p>

<p>Unlike volumes, Docker requires to create a network before it can be used. <code class="language-plaintext highlighter-rouge">docker network ls</code> lists all the existing network in your local machine. With a network created, a container can be run based as a part of the network. Containers that are part of the network can communicate with just the name of the container.
<code class="language-plaintext highlighter-rouge">docker run --network my_network image_name ...</code>
Recall that you need to edit your database url, e.g., <code class="language-plaintext highlighter-rouge">localhost</code> -&gt; <code class="language-plaintext highlighter-rouge">container_name</code></p>

<h2 id="section-5">Section 5</h2>

<h3 id="docker-compose">Docker Compose</h3>

<p><a href="https://docs.docker.com/compose/">Docker Compose</a> is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration, instead of running several Docker commands with CLI.</p>

<h4 id="why-docker-compose">Why Docker Compose?</h4>

<p>Consider this made-up example below: <br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create shop
docker build -t shop-node .
docker run -v logs:/app/logs --network shop --name shope-web shop-node
docker build -t shop-database
docker run -v data:/data/db --network shop --name shop-db shop-database
</code></pre></div></div>

<p>This simple example requires a lot commands to execute to run all containers required by this application. Often, you run these commands whenever you change something in your code or
you need to bring up your containers again for some other reason. Running these commands may be daunting because you have to memorize and making changes in CLI ius not flexible like conventional text editors.</p>

<p>With Docker Compose, this gets much easier. You can put your container configuration into a docker-compose.yaml file and then use just one command to bring up the entire environment: docker-compose up .</p>

<p>Using Compose is basically a three-step process:</p>

<ol>
  <li>
    <p>Define your app’s environment with a Dockerfile so it can be reproduced anywhere.</p>
  </li>
  <li>
    <p>Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.</p>
  </li>
  <li>
    <p>Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary.</p>
  </li>
</ol>

<p>A docker-compose.yml looks like this: <br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: "3.8" # version of the Docker Compose spec which is being used
services: # "Services" are in the end the Containers that your app needs
  web:
    build: . # Directory of the Dockerfile
    ports: # Specify published ports
      - '80:80'
    volumes: # Define any required volumes / bind mounts
      - logs:/app/logs # named volume
      - ./backend:/app # bind mount
      - /app/node_modules # anonymous volume
    environment:
      - MONGODB_USERNAME=ali
      - MONGODB_PASSWORD=secret
    mongodb:
    image: 'mongo' # THe image URL
    volumes:
      - data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=ali
      - MONGO_INITDB_ROOT_PASSWORD=secret
# SPecify all the named volumes here
volumes:
  logs:
  data:
</code></pre></div></div>

<p>You can conveniently edit this file at any time and you just have a short, simple command which you can use to bring up your Containers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up
</code></pre></div></div>

<h4 id="docker-compose-key-commands">Docker Compose Key Commands</h4>

<p>There are two key commands:</p>

<ul>
  <li><strong>docker-compose up</strong> : Start all containers / services mentioned in the Docker Compose file
    <ul>
      <li>-d : Start in detached mode</li>
      <li>–build : Force Docker Compose to re-evaluate / rebuild all images (otherwise, it onlydoes that if an image is missing)</li>
    </ul>
  </li>
  <li><strong>docker-compose down</strong> : Stop and remove all containers / services
    <ul>
      <li>-v : Remove all Volumes used for the Containers - otherwise they stay around, even if the Containers are removed</li>
    </ul>
  </li>
</ul>

<p>Of course, there are <a href="https://docs.docker.com/compose/reference/">more commands</a></p>

          <!-- <footer>
            <a
              href="https://twitter.com/aidanfeldman"
              class="twitter-follow-button"
              data-show-count="false"
              data-size="large"
              >Follow @aidanfeldman</a
            >
            <script>
              !(function(d, s, id) {
                var js,
                  fjs = d.getElementsByTagName(s)[0],
                  p = /^http:/.test(d.location) ? "http" : "https";
                if (!d.getElementById(id)) {
                  js = d.createElement(s);
                  js.id = id;
                  js.src = p + "://platform.twitter.com/widgets.js";
                  fjs.parentNode.insertBefore(js, fjs);
                }
              })(document, "script", "twitter-wjs");
            </script>
          </footer> -->
        </div>
      </div>
    </div>
  </body>
</html>
